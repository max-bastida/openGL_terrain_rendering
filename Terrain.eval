#version 400

layout(quads, equal_spacing, ccw) in;

out vec3 Normal;
out vec3 position;
out vec2 texCoord;
out float height;

uniform mat4 mvpMatrix;
uniform sampler2D heightMap;
uniform float waterHeight;
uniform int tick;
uniform float wave_mag;
uniform float freq;
uniform float speed;


void main()
{
    float xmin = -45, xmax = +45, zmin = 0, zmax = -90;
    vec4 posn;
    vec2 tcoord;

    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    posn = (1-u) * (1-v) * gl_in[0].gl_Position + u * (1-v) * gl_in[1].gl_Position + u * v * gl_in[2].gl_Position + (1-u) * v * gl_in[3].gl_Position;

    tcoord.s = (posn.x - xmin)/(xmax-xmin);
    tcoord.t = (posn.z - zmin)/(zmax-zmin);

    height = texture(heightMap, tcoord).r * 10.0;
    posn.y = height;

    float sample_dist = 0.00001;
    vec2 tcoordn;
    tcoordn.s = tcoord.s;
    tcoordn.t = tcoord.t - sample_dist;
    float yn = texture(heightMap, tcoordn).r;

    vec2 tcoords;
    tcoords.s = tcoord.s;
    tcoords.t = tcoord.t + sample_dist;
    float ys = texture(heightMap, tcoords).r;

    vec2 tcoorde;
    tcoorde.s = tcoord.s + sample_dist;
    tcoorde.t = tcoord.t;
    float ye = texture(heightMap, tcoorde).r;

    vec2 tcoordw;
    tcoordw.s = tcoord.s - sample_dist;
    tcoordw.t = tcoord.t;
    float yw = texture(heightMap, tcoordw).r;

    if (posn.y < waterHeight){
        float depth = (waterHeight - posn.y)/(waterHeight);
        float m = wave_mag * (1-depth);
        float f = freq;
        posn.y = waterHeight + m * sin(f * (depth + speed * tick));

        float depths = (waterHeight - ys)/(waterHeight);
        float ms = wave_mag * (1-depths);
        ys = waterHeight + ms * sin(f * (depths + speed * tick));
        
        float depthw = (waterHeight - yw)/(waterHeight);
        float mw = wave_mag * (1-depthw);
        yw = waterHeight + mw * sin(f * (depthw + speed * tick));
        
        float depthe = (waterHeight - ye)/(waterHeight);
        float me = wave_mag * (1-depthe);
        ye = waterHeight + me * sin(f * (depthe + speed * tick));
        
        float depthn = (waterHeight - yn)/(waterHeight);
        float mn = wave_mag * (1-depthn);
        yn = waterHeight + mn * sin(f * (depthn + speed * tick));
    }
    position = vec3(posn.x, posn.y, posn.z);
    texCoord = vec2(u,v);

    vec3 n = vec3(2 * (yw - ye) * sample_dist, 4 * sample_dist * sample_dist, 2 * (yn - ys) * sample_dist);
    Normal = normalize(n);

    gl_Position = mvpMatrix * posn;
}
